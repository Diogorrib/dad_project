
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}

%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{DIDA-TKVS - A Distributed Transactional Key-Value Store}

\author{André Matos - 92420\\
andre.matos@tecnico.ulisboa.pt\\
\and
Diogo Ribeiro - 102484\\
diogo.l.ribeiro@tecnico.ulisboa.pt\\
\and
Luís Calado - 103883\\
luis.maria.calado@tecnico.ulisboa.pt\\
}

\maketitle
\thispagestyle{empty}

\begin{abstract}
   The ABSTRACT is to be in fully-justified italicized text, at the top 
   of the left-hand column, below the author and affiliation 
   information. Use the word ``Abstract'' as the title, in 12-point 
   Times, boldface type, centered relative to the column, initially 
   capitalized. The abstract is to be in 10-point, single-spaced type. 
   The abstract may be up to 3 inches (7.62 cm) long. Leave two blank 
   lines after the Abstract, then begin the main text. 
\end{abstract}



%------------------------------------------------------------------------- 
\Section{Introduction}

In this project we implemented a distributed transactional
key-value store, called DIDA-TKV. The developed system is
composed by multiple Servers that work together to ensure
linearizability while tolerating faults in a minority of
replicas. To achieve this, we used the Paxos
consensus algorithm to order requests received from clients.
We assume that a server may crash or "freeze" (while in freeze mode, the
server will not receive requests from clients nor learn the order
agreed by other servers). Also, servers may be in slow mode
(each server can receive requests in a different order).
Byzantine failures are not tolerated by the system.

This project was implemented in Java using asynchronous
programming. The communication between processes was
achieved using gRPC and the communication protocol was
established using Protocol Buffers.

%------------------------------------------------------------------------- 
\Section{Paxos}

TODO: mais cenas aqui

Paxos' consensus consists of 2 phases,
followed by a learn phase of the value agreed.

\SubSection{Roles}

Paxos defines three roles in the system, which must cooperate to achieve
consensus. These roles are: Proposer, Acceptor and Learner.

In our implementation, we have 5 servers, 3 of which act as proposers and
simultaneously as acceptors, and all of the servers are learners. 

\SubSection{Prepare and promise}

The first phase of Paxos starts when some proposer receives a request
from a client. The server sends a prepare message to all acceptors with
its leader id / proposal number, then waits for a majority of responses. After that,
if the majority accepts it as leader, server becomes the leader and
can proceed to the following phase.

The role of acceptors in this phase is to promise to the server
that sent the prepare message, if the leader id is the same or
bigger than the last they have seen. The promise message also lets the
leader know if any previous leader has proposed a value
for that instance, so that it can adopt the previous proposed value.
So the server will propose that value again, ensuring continuity
in the consensus process and preventing conflicting proposals.

There is the possibility that the server can be rejected if
some acceptor already promised to a leader with higher id.
In this case, the server will increase its id and try again right
after being rejected. Compared to timeout after rejection,
this solution can reduce the overall time to reach consensus.
If the conditions that led to the rejection have changed,
the server may succeed without waiting for the timeout.

\SubSection{Accept and Accepted}

After receiving a majority of promises from the acceptors, the proposer 
initiates the second phase of Paxos. In the second phase, the proposer 
sends an accept message to all the acceptors, with the value (requestId) 
it wants them to accept. The acceptors, upon receiving the accept message,
check if the proposal number is the same as the one they promised to accept
and, if so, they accept the value (sending an accepted message to proposer)
and send a learn message to the learners.
Leader knows that second phase is completed if the majority of acceptors
accept the proposed value. In case of rejection, first phase of Paxos must
be repeated before trying to propose the value again.

\SubSection{Learn After Consensus}

The learners, upon receiving a majority of learn
messages, know that consensus was reached, so they can execute
the request on the key-value store in total order and reply to the client.

\SubSection{Design Choices}

When the leader id in prepare/accept message is lower, instead of
ignoring, acceptor informs the server that it was rejected.
One advantage of the approach is that proposer doesn't have to wait
for a timeout to infer that it was rejected, allowing the proposer
to retry phase one with a higher proposal number.
However, this adds extra messages to the networks and could lead to
higher network congestion and latency, but rejections are not
so frequent and the impact on network performance may be minimal in most cases.

Phase one allow proposer to efficiently increase its timestamp by
receiving the highest timestamp that acceptor has promised to.

%------------------------------------------------------------------------- 
\Section{Reconfiguration}

WHICH IMPLEMENTATION DID WE USE? STOPPABLE PAXOS?
TODO: explain consoleClient

It's possible to change at a given time the servers that act as "proposers"
and "acceptors", for doing so, the consoleClient sends a commit message to a
special key (the key 0). Upon receiving the commit message, the server can easily
understand that this request is a reconfiguration request, given that only the
consoleClient can write in the special key and that its client id is 0.

Therefore, it's possible to execute a special command, the \textbf{stop command},
that will stop the next requests from starting Paxos, until the reconfiguration
is complete.

For the reconfiguration, the leader/proposer executes Paxos as usual, and after
consensus is reached, will change the configuration and release the stop 
command. The other servers, if they accept the new configuration, will also
proceed to change their own configuration, learning their new roles for the
following instances. If server that proposed reconfiguration is rejected,
it will also release the stop.

%------------------------------------------------------------------------- 
\Section{Multi-Paxos}

For Multi-Paxos, a proposer can start a new instance of consensus while the 
others are still executing, allowing for multiple instances to be running at the
same time, and consequently a more efficient system.

Another optimization of multipaxos is that allows that prepare can be executed
only once, executing this phase in a single message for multiple instances,
[X, infinity]. Then when receives a new request, the proposer only needs to
execute second phase of Paxos, after prepare was accepted for the first time.
Acceptors, when promising to the leader, also send all proposed values
from previous leader for each instance up to infinity.

%------------------------------------------------------------------------- 
\nocite{ex1,ex2}
\bibliographystyle{latex8}
\bibliography{latex8}

\end{document}

